package com.example.airline.Service;import com.example.airline.Entity.Booking;import com.example.airline.Entity.Flight;import com.example.airline.Entity.User;import com.example.airline.Repositery.BookingRepositroy;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.time.LocalDateTime;import java.util.ArrayList;import java.util.List;import java.util.stream.Collectors;@Servicepublic class BookingService {    @Autowired    private BookingRepositroy bookingRepositroy;    @Autowired    private  EmailService emailService;    @Autowired    private FlightService flightService;    @Autowired    private UserService userService;    public Booking bookFlight(Long userId, Long flightId, String seatNumber) {        try{        User user = userService.getUserById(userId);        // Validate flight exists        Flight flight = flightService.getFlightById(flightId);        // Check if seat is available        if (!isSeatAvailable(flightId, seatNumber)) {            throw new RuntimeException("Seat " + seatNumber + " is already booked");        }            // Check if flight has capacity            List<Booking> existingBookings = bookingRepositroy.findByFlightId(flightId);            if (existingBookings.size() >= flight.getTotalSeats()) {                throw new RuntimeException("Flight is fully booked");            }            Booking booking = new Booking();            booking.setUser(user);            booking.setFlight(flight);            booking.setSeatNumber(seatNumber);            booking.setBookingTime(LocalDateTime.now());            Booking savedBooking  = bookingRepositroy.save(booking);            emailService.sendMail(                    user.getEmail(),                    "Flight Booking Confirmation",                    buildEmailBody(user,flight,booking)            );            return savedBooking;        }        catch (Exception e){            throw  new RuntimeException("User is not found in db"+e.getMessage());        }    }    private String buildEmailBody(User user, Flight flight, Booking booking) {        return "Dear " + user.getName() + ",\n\n" +                "Your booking is confirmed!\n" +                "Booking ID: " + booking.getId() + "\n" +                "Flight: " + flight.getAirline() + "\n" +                "Route: " + flight.getSource() + " â†’ " + flight.getDestination() + "\n" +                "Seat: " + booking.getSeatNumber() + "\n" +                "Date: " + flight.getDepartureDate() + "\n\n" +                "Thank you for booking with us!";    }    public List<Booking> getUserBookings(Long userId) {        userService.getUserById(userId); // Validate user exists        return bookingRepositroy.findByUserId(userId);    }    public List<Booking> getFlightBookings(Long flightId) {        flightService.getFlightById(flightId); // Validate flight exists        return bookingRepositroy.findByFlightId(flightId);    }    public Booking getBookingById(Long id) {        return bookingRepositroy.findById(id)                .orElseThrow(() -> new RuntimeException("Booking not found with id: " + id));    }    public List<Booking> getAllBookings() {        return bookingRepositroy.findAll();    }    public void cancelBooking(Long id) {        Booking booking = getBookingById(id);        // Check if cancellation is allowed (e.g., not past departure time)        LocalDateTime now = LocalDateTime.now();        LocalDateTime departureDateTime = LocalDateTime.of(                booking.getFlight().getDepartureDate(),                booking.getFlight().getDepartureTime()        );        if (now.isAfter(departureDateTime)) {            throw new RuntimeException("Cannot cancel booking after departure time");        }        bookingRepositroy.delete(booking);    }    public List<String> getAvailableSeats(Long flightId) {        Flight flight = flightService.getFlightById(flightId);        List<Booking> bookedSeats = bookingRepositroy.findByFlightId(flightId);        // Generate all possible seats (assuming seats are like 1A, 1B, 2A, 2B, etc.)        List<String> allSeats = generateAllSeats(flight.getTotalSeats());        // Get booked seat numbers        List<String> bookedSeatNumbers = bookedSeats.stream()                .map(Booking::getSeatNumber)                .collect(Collectors.toList());        // Return available seats        return allSeats.stream()                .filter(seat -> !bookedSeatNumbers.contains(seat))                .collect(Collectors.toList());    }    public long getTotalBookings() {        return bookingRepositroy.count();    }    private boolean isSeatAvailable(Long flightId, String seatNumber) {        List<Booking> bookings = bookingRepositroy.findByFlightId(flightId);        return bookings.stream().noneMatch(booking -> booking.getSeatNumber().equals(seatNumber));    }    private List<String> generateAllSeats(int totalSeats) {        List<String> seats = new ArrayList<>();        int seatsPerRow = 6; // Assuming 6 seats per row (A, B, C, D, E, F)        char[] seatLetters = {'A', 'B', 'C', 'D', 'E', 'F'};        int rows = (int) Math.ceil((double) totalSeats / seatsPerRow);        for (int row = 1; row <= rows; row++) {            for (int seatIndex = 0; seatIndex < seatsPerRow && seats.size() < totalSeats; seatIndex++) {                seats.add(row + String.valueOf(seatLetters[seatIndex]));            }        }        return seats;    }    public boolean hasUserBookedFlight(Long userId, Long flightId) {        List<Booking> userBookings = getUserBookings(userId);        return userBookings.stream()                .anyMatch(booking -> booking.getFlight().getId().equals(flightId));    }    public List<Booking> getUpcomingBookings(Long userId) {        List<Booking> userBookings = getUserBookings(userId);        LocalDateTime now = LocalDateTime.now();        return userBookings.stream()                .filter(booking -> {                    LocalDateTime departureDateTime = LocalDateTime.of(                            booking.getFlight().getDepartureDate(),                            booking.getFlight().getDepartureTime()                    );                    return departureDateTime.isAfter(now);                })                .collect(Collectors.toList());    }}